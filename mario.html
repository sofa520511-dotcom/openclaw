<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ë∂ÖÁ¥öÁë™Âà©Ê≠ê üçÑ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, #5c94fc 0%, #5c94fc 60%, #8b4513 100%);
            font-family: 'Segoe UI', 'Courier New', monospace;
            overflow: hidden;
        }

        .game-header {
            color: white;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 3px 3px 0 #000;
        }

        .game-header h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .stats {
            display: flex;
            gap: 25px;
            font-size: 0.9rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-container {
            position: relative;
            border: 4px solid #000;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        canvas {
            display: block;
            background: linear-gradient(180deg, #5c94fc 0%, #5c94fc 70%, transparent 70%);
        }

        .controls {
            margin-top: 15px;
            color: white;
            text-align: center;
            font-size: 0.7rem;
            text-shadow: 2px 2px 0 #000;
        }

        .mobile-controls {
            display: flex;
            margin-top: 20px;
            gap: 10px;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            text-shadow: 2px 2px 0 #000;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }

        .jump-btn {
            width: 80px;
            height: 80px;
            font-size: 0.8rem;
            margin-left: 30px;
        }

        /* ÊâãÊ©üÁõ¥Âêë */
        @media (max-width: 600px) {
            canvas {
                max-width: 100vw;
            }
        }

        /* ÊâãÊ©üÊ©´Âêë */
        @media (max-height: 500px) and (orientation: landscape) {
            body {
                padding: 5px;
                justify-content: flex-start;
            }
            .game-header {
                margin-bottom: 5px;
            }
            .game-header h1 {
                font-size: 1.2rem;
                margin-bottom: 5px;
            }
            .stats {
                font-size: 0.7rem;
                gap: 15px;
            }
            .game-container {
                padding: 0;
            }
            canvas {
                max-height: 55vh;
                width: auto;
            }
            .mobile-controls {
                position: fixed;
                bottom: 10px;
                left: 0;
                right: 0;
                justify-content: center;
                margin: 0;
                z-index: 100;
            }
            .mobile-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
            .jump-btn {
                width: 65px;
                height: 65px;
                margin-left: 50px;
            }
            .controls {
                display: none;
            }
        }

        /* ÈõªËÖ¶Â§ßËû¢ÂπïÈö±ËóèËôõÊì¨ÊåâÈàï */
        @media (min-width: 1025px) and (hover: hover) {
            .mobile-controls {
                display: none;
            }
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2rem;
            border: 4px solid #ffd700;
            z-index: 100;
        }

        .message button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 1rem;
            font-family: inherit;
            cursor: pointer;
            background: #e52521;
            color: white;
            border: none;
            border-radius: 5px;
            margin-left: 5px;
            margin-right: 5px;
        }

        .message button:hover {
            background: #ff3b30;
        }

        .message button.green {
            background: #22c55e;
        }

        .message button.green:hover {
            background: #16a34a;
        }

        .level-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #ffd700;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: bold;
            z-index: 50;
            animation: fadeOut 2s forwards;
            animation-delay: 1s;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>üçÑ Ë∂ÖÁ¥öÁë™Âà©Ê≠ê</h1>
        <div class="stats">
            <span>ÈóúÂç°: <span id="level">1</span>/10 üè∞</span>
            <span>ÈáëÂπ£: <span id="coins">0</span> ü™ô</span>
            <span>ÂàÜÊï∏: <span id="score">0</span></span>
            <span>ÁîüÂëΩ: <span id="lives">3</span> ‚ù§Ô∏è</span>
        </div>
    </div>
    
    <div class="game-container">
        <canvas id="game" width="800" height="400"></canvas>
    </div>
    
    <p class="controls">‚Üê ‚Üí ÁßªÂãï ÔΩú Á©∫ÁôΩÈçµ Ë∑≥Ë∫ç ÔΩú Ë∏©Êïµ‰∫∫ÂæóÂàÜÔºÅ</p>
    
    <div class="mobile-controls">
        <button class="mobile-btn" id="leftBtn">‚óÄ</button>
        <button class="mobile-btn" id="rightBtn">‚ñ∂</button>
        <button class="mobile-btn jump-btn" id="jumpBtn">Ë∑≥</button>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = true;
        let coins = 0;
        let score = 0;
        let lives = 3;
        let currentLevel = 1;
        let cameraX = 0;
        let levelComplete = false;
        let totalLevels = 10;

        // Mario
        const mario = {
            x: 50,
            y: 300,
            width: 32,
            height: 40,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpForce: -14,
            grounded: false,
            facing: 1,
            frame: 0,
            frameTimer: 0
        };

        // Physics
        const gravity = 0.6;
        const friction = 0.8;

        // Level data
        let platforms = [];
        let coinList = [];
        let enemies = [];
        let flag = { x: 2000, y: 160, width: 10, height: 200 };
        let levelLength = 2000;

        // Level generation based on difficulty
        function generateLevel(level) {
            platforms = [];
            coinList = [];
            enemies = [];

            // Difficulty scaling
            const difficulty = level;
            const gapChance = 0.1 + (level * 0.03); // More gaps at higher levels
            const enemySpeed = 1.5 + (level * 0.2); // Faster enemies
            const enemyCount = 3 + Math.floor(level * 1.5); // More enemies
            const platformCount = Math.max(4, 10 - Math.floor(level * 0.5)); // Fewer platforms
            levelLength = 1500 + (level * 200); // Longer levels
            
            // Generate ground with gaps
            let groundX = 0;
            const groundSegments = [];
            
            while (groundX < levelLength + 500) {
                const segmentLength = 200 + Math.random() * 300;
                groundSegments.push({ x: groundX, width: segmentLength });
                groundX += segmentLength;
                
                // Add gap based on difficulty
                if (Math.random() < gapChance && groundX < levelLength) {
                    const gapWidth = 80 + Math.random() * (40 + level * 10);
                    groundX += gapWidth;
                }
            }

            // Add ground platforms
            for (const seg of groundSegments) {
                platforms.push({
                    x: seg.x,
                    y: 360,
                    width: seg.width,
                    height: 40,
                    type: 'ground'
                });
            }

            // Generate floating platforms
            const platformSpacing = levelLength / (platformCount + 1);
            for (let i = 0; i < platformCount; i++) {
                const px = 150 + i * platformSpacing + Math.random() * 100;
                const py = 180 + Math.random() * 120;
                const pwidth = 60 + Math.random() * 60;
                const ptype = Math.random() > 0.7 ? 'question' : 'brick';
                
                platforms.push({
                    x: px,
                    y: py,
                    width: pwidth,
                    height: 20,
                    type: ptype
                });

                // Add coin above platform
                if (Math.random() > 0.3) {
                    coinList.push({
                        x: px + pwidth / 2,
                        y: py - 40,
                        collected: false
                    });
                }
            }

            // Add some coins on ground
            for (let i = 0; i < 5 + level; i++) {
                const cx = 200 + Math.random() * (levelLength - 300);
                coinList.push({
                    x: cx,
                    y: 320,
                    collected: false
                });
            }

            // Generate enemies
            for (let i = 0; i < enemyCount; i++) {
                const ex = 300 + (i * (levelLength - 400) / enemyCount);
                
                // Find ground at this position
                let groundY = 360;
                for (const plat of platforms) {
                    if (plat.type === 'ground' && ex >= plat.x && ex <= plat.x + plat.width) {
                        groundY = plat.y;
                        break;
                    }
                }

                // Different enemy types at higher levels
                const enemyType = level >= 5 && Math.random() > 0.6 ? 'koopa' : 'goomba';
                const speed = enemySpeed * (enemyType === 'koopa' ? 1.3 : 1);

                enemies.push({
                    x: ex,
                    y: groundY - 32,
                    width: 32,
                    height: 32,
                    vx: (Math.random() > 0.5 ? 1 : -1) * speed,
                    alive: true,
                    type: enemyType
                });
            }

            // Special challenges for later levels
            if (level >= 7) {
                // Add moving platforms
                for (let i = 0; i < level - 5; i++) {
                    platforms.push({
                        x: 400 + i * 300,
                        y: 250,
                        width: 80,
                        height: 20,
                        type: 'moving',
                        startX: 400 + i * 300,
                        moveRange: 100,
                        moveSpeed: 1 + level * 0.1
                    });
                }
            }

            // Flag position
            flag = { x: levelLength, y: 160, width: 10, height: 200 };

            // Level-specific backgrounds
            updateBackground(level);
        }

        function updateBackground(level) {
            // Different sky colors for different worlds
            const backgrounds = [
                '#5c94fc', // Classic blue
                '#5c94fc',
                '#87CEEB', // Light blue
                '#87CEEB',
                '#ff9966', // Sunset
                '#ff9966',
                '#2c1654', // Night
                '#2c1654',
                '#1a0a2e', // Dark night
                '#ff4444', // Lava red
            ];
            
            const bg = backgrounds[Math.min(level - 1, backgrounds.length - 1)];
            canvas.style.background = `linear-gradient(180deg, ${bg} 0%, ${bg} 70%, transparent 70%)`;
            document.body.style.background = `linear-gradient(180deg, ${bg} 0%, ${bg} 60%, #8b4513 100%)`;
        }

        // Input
        const keys = {};

        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        // Mobile controls
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');

        leftBtn.addEventListener('touchstart', e => { e.preventDefault(); keys['ArrowLeft'] = true; });
        leftBtn.addEventListener('touchend', e => { e.preventDefault(); keys['ArrowLeft'] = false; });
        rightBtn.addEventListener('touchstart', e => { e.preventDefault(); keys['ArrowRight'] = true; });
        rightBtn.addEventListener('touchend', e => { e.preventDefault(); keys['ArrowRight'] = false; });
        jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); keys['Space'] = true; });
        jumpBtn.addEventListener('touchend', e => { e.preventDefault(); keys['Space'] = false; });

        function update() {
            if (!gameRunning || levelComplete) return;

            // Update moving platforms
            for (const plat of platforms) {
                if (plat.type === 'moving') {
                    plat.x += plat.moveSpeed;
                    if (plat.x > plat.startX + plat.moveRange || plat.x < plat.startX - plat.moveRange) {
                        plat.moveSpeed *= -1;
                    }
                }
            }

            // Input
            if (keys['ArrowLeft'] || keys['KeyA']) {
                mario.vx = -mario.speed;
                mario.facing = -1;
            } else if (keys['ArrowRight'] || keys['KeyD']) {
                mario.vx = mario.speed;
                mario.facing = 1;
            } else {
                mario.vx *= friction;
            }

            if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && mario.grounded) {
                mario.vy = mario.jumpForce;
                mario.grounded = false;
            }

            // Physics
            mario.vy += gravity;
            mario.x += mario.vx;
            mario.y += mario.vy;

            // Keep mario from going left of start
            if (mario.x < 0) mario.x = 0;

            // Animation
            if (Math.abs(mario.vx) > 0.5) {
                mario.frameTimer++;
                if (mario.frameTimer > 6) {
                    mario.frame = (mario.frame + 1) % 3;
                    mario.frameTimer = 0;
                }
            } else {
                mario.frame = 0;
            }

            // Platform collision
            mario.grounded = false;
            for (const plat of platforms) {
                if (mario.x + mario.width > plat.x && mario.x < plat.x + plat.width) {
                    if (mario.y + mario.height > plat.y && mario.y + mario.height < plat.y + plat.height + mario.vy + 5) {
                        if (mario.vy >= 0) {
                            mario.y = plat.y - mario.height;
                            mario.vy = 0;
                            mario.grounded = true;
                            
                            // Move with moving platform
                            if (plat.type === 'moving') {
                                mario.x += plat.moveSpeed;
                            }
                        }
                    }
                }
            }

            // Coin collection
            for (const coin of coinList) {
                if (!coin.collected) {
                    const dx = (mario.x + mario.width / 2) - coin.x;
                    const dy = (mario.y + mario.height / 2) - coin.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 25) {
                        coin.collected = true;
                        coins++;
                        score += 100;
                        updateStats();
                    }
                }
            }

            // Enemy update & collision
            for (const enemy of enemies) {
                if (!enemy.alive) continue;

                enemy.x += enemy.vx;

                // Enemy boundary check
                for (const plat of platforms) {
                    if (plat.type === 'ground') {
                        if (enemy.x >= plat.x && enemy.x + enemy.width <= plat.x + plat.width) {
                            // On this platform
                        } else if (enemy.y + enemy.height >= plat.y - 5) {
                            // Check if about to fall off
                            let onPlatform = false;
                            for (const p2 of platforms) {
                                if (p2.type === 'ground' && enemy.x >= p2.x && enemy.x + enemy.width <= p2.x + p2.width) {
                                    onPlatform = true;
                                    break;
                                }
                            }
                            if (!onPlatform && enemy.y < 350) {
                                enemy.vx *= -1;
                            }
                        }
                    }
                }

                // Screen boundary
                if (enemy.x < 0 || enemy.x > levelLength + 200) {
                    enemy.vx *= -1;
                }

                // Mario vs Enemy
                if (mario.x + mario.width > enemy.x + 5 && mario.x + 5 < enemy.x + enemy.width &&
                    mario.y + mario.height > enemy.y && mario.y < enemy.y + enemy.height) {
                    
                    if (mario.vy > 0 && mario.y + mario.height < enemy.y + enemy.height / 2 + mario.vy + 5) {
                        // Stomp enemy
                        enemy.alive = false;
                        mario.vy = -10;
                        score += 200 * currentLevel; // More points at higher levels
                        updateStats();
                    } else {
                        // Hit by enemy
                        loseLife();
                    }
                }
            }

            // Fall death
            if (mario.y > 500) {
                loseLife();
            }

            // Camera
            cameraX = mario.x - canvas.width / 3;
            if (cameraX < 0) cameraX = 0;
            if (cameraX > levelLength - canvas.width + 200) cameraX = levelLength - canvas.width + 200;

            // Level complete
            if (mario.x > flag.x) {
                levelComplete = true;
                const bonus = (10 - Math.floor((Date.now() % 100000) / 10000)) * 100 * currentLevel;
                score += bonus;
                updateStats();
                
                if (currentLevel >= totalLevels) {
                    showMessage('üéä ÊÅ≠ÂñúÂÖ®Á†¥ÔºÅ', `ÊúÄÁµÇÂàÜÊï∏: ${score}<br>‰Ω†ÊòØÁúüÊ≠£ÁöÑË∂ÖÁ¥öÁë™Âà©Ê≠êÔºÅ`, 'complete');
                } else {
                    showMessage(`üéâ Á¨¨ ${currentLevel} ÈóúÈÅéÈóúÔºÅ`, `ÂàÜÊï∏: ${score}<br>ÁçéÂãµ: +${bonus}`, 'nextLevel');
                }
            }
        }

        function loseLife() {
            lives--;
            updateStats();
            if (lives <= 0) {
                gameRunning = false;
                showMessage('üíÄ ÈÅäÊà≤ÁµêÊùü', `ÊúÄÁµÇÂàÜÊï∏: ${score}<br>Âà∞ÈÅîÁ¨¨ ${currentLevel} Èóú`, 'gameOver');
            } else {
                resetMarioPosition();
            }
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#5c94fc';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-cameraX, 0);

            // Background elements
            drawBackground();

            // Platforms
            for (const plat of platforms) {
                if (plat.type === 'ground') {
                    ctx.fillStyle = currentLevel >= 9 ? '#4a1a1a' : '#8b4513';
                    ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
                    ctx.fillStyle = currentLevel >= 9 ? '#ff4444' : '#228b22';
                    ctx.fillRect(plat.x, plat.y, plat.width, 10);
                } else if (plat.type === 'brick') {
                    drawBrick(plat.x, plat.y, plat.width, plat.height);
                } else if (plat.type === 'question') {
                    drawQuestionBlock(plat.x, plat.y, plat.width, plat.height);
                } else if (plat.type === 'moving') {
                    ctx.fillStyle = '#888';
                    ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
                    ctx.fillStyle = '#aaa';
                    ctx.fillRect(plat.x, plat.y, plat.width, 5);
                }
            }

            // Coins
            for (const coin of coinList) {
                if (!coin.collected) {
                    drawCoin(coin.x, coin.y);
                }
            }

            // Enemies
            for (const enemy of enemies) {
                if (enemy.alive) {
                    if (enemy.type === 'koopa') {
                        drawKoopa(enemy.x, enemy.y, enemy.width, enemy.height, enemy.vx);
                    } else {
                        drawGoomba(enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                }
            }

            // Flag
            drawFlag(flag.x, flag.y);

            // Mario
            drawMario();

            ctx.restore();

            // Level indicator on screen
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(10, 10, 80, 30);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`W${currentLevel}`, 50, 30);
        }

        function drawBackground() {
            // Clouds
            ctx.fillStyle = currentLevel >= 7 ? 'rgba(255,255,255,0.3)' : 'white';
            const cloudOffset = cameraX * 0.3;
            for (let i = 0; i < 10; i++) {
                const x = i * 300 - (cloudOffset % 300);
                const y = 40 + (i % 3) * 30;
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.arc(x + 30, y - 10, 30, 0, Math.PI * 2);
                ctx.arc(x + 60, y, 25, 0, Math.PI * 2);
                ctx.fill();
            }

            // Hills (parallax)
            if (currentLevel < 7) {
                ctx.fillStyle = '#228b22';
                for (let i = 0; i < 8; i++) {
                    const hx = i * 400 - (cameraX * 0.2 % 400);
                    ctx.beginPath();
                    ctx.arc(hx, 360, 80 + (i % 2) * 30, Math.PI, 0);
                    ctx.fill();
                }
            }

            // Stars for night levels
            if (currentLevel >= 7) {
                ctx.fillStyle = 'white';
                for (let i = 0; i < 50; i++) {
                    const sx = (i * 137 + cameraX * 0.1) % (levelLength + 500);
                    const sy = (i * 73) % 200;
                    ctx.fillRect(sx, sy, 2, 2);
                }
            }
        }

        function drawBrick(x, y, w, h) {
            ctx.fillStyle = currentLevel >= 9 ? '#8b0000' : '#c84c0c';
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
            ctx.strokeStyle = currentLevel >= 9 ? '#5a0000' : '#8b3000';
            for (let i = 0; i < w; i += 20) {
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + h);
                ctx.stroke();
            }
        }

        function drawQuestionBlock(x, y, w, h) {
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
            ctx.fillStyle = '#8b4513';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('?', x + w / 2, y + h / 2 + 6);
        }

        function drawCoin(x, y) {
            const wobble = Math.sin(Date.now() / 200) * 2;
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.ellipse(x, y + wobble, 10, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#daa520';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawGoomba(x, y, w, h) {
            ctx.fillStyle = '#8b4513';
            ctx.beginPath();
            ctx.ellipse(x + w / 2, y + h / 2 + 5, w / 2, h / 2 - 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#a0522d';
            ctx.beginPath();
            ctx.ellipse(x + w / 2, y + 8, w / 2 + 2, 12, 0, Math.PI, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(x + 10, y + 12, 5, 6, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 22, y + 12, 5, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + 10, y + 13, 2, 0, Math.PI * 2);
            ctx.arc(x + 22, y + 13, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 2, y + h - 5, 10, 5);
            ctx.fillRect(x + w - 12, y + h - 5, 10, 5);
        }

        function drawKoopa(x, y, w, h, vx) {
            // Shell
            ctx.fillStyle = '#22c55e';
            ctx.beginPath();
            ctx.ellipse(x + w / 2, y + h / 2 + 5, w / 2 + 2, h / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#15803d';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Head
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.ellipse(x + (vx > 0 ? w - 5 : 5), y + 8, 10, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + (vx > 0 ? w - 5 : 5), y + 6, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + (vx > 0 ? w - 3 : 7), y + 6, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawFlag(x, y) {
            ctx.fillStyle = '#228b22';
            ctx.fillRect(x, y, 8, 200);
            
            ctx.fillStyle = currentLevel >= totalLevels ? '#ffd700' : '#ff0000';
            ctx.beginPath();
            ctx.moveTo(x + 8, y);
            ctx.lineTo(x + 60, y + 25);
            ctx.lineTo(x + 8, y + 50);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(x + 4, y, 8, 0, Math.PI * 2);
            ctx.fill();

            // Level number on flag
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(currentLevel, x + 35, y + 30);
        }

        function drawMario() {
            const x = mario.x;
            const y = mario.y;
            const dir = mario.facing;

            ctx.save();
            if (dir === -1) {
                ctx.translate(x + mario.width, 0);
                ctx.scale(-1, 1);
                ctx.translate(-x, 0);
            }

            // Hat
            ctx.fillStyle = '#e52521';
            ctx.fillRect(x + 6, y, 20, 8);
            ctx.fillRect(x + 2, y + 8, 28, 6);

            // Face
            ctx.fillStyle = '#fdbf6f';
            ctx.fillRect(x + 6, y + 14, 20, 12);

            // Eye
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 18, y + 16, 4, 4);

            // Mustache
            ctx.fillStyle = '#4a2800';
            ctx.fillRect(x + 10, y + 22, 14, 4);

            // Body
            ctx.fillStyle = '#e52521';
            ctx.fillRect(x + 4, y + 26, 24, 14);

            // Overalls
            ctx.fillStyle = '#0066cc';
            ctx.fillRect(x + 6, y + 32, 20, 8);

            ctx.restore();
        }

        function updateStats() {
            document.getElementById('level').textContent = currentLevel;
            document.getElementById('coins').textContent = coins;
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
        }

        function resetMarioPosition() {
            mario.x = 50;
            mario.y = 300;
            mario.vx = 0;
            mario.vy = 0;
            cameraX = 0;
        }

        function nextLevel() {
            currentLevel++;
            levelComplete = false;
            generateLevel(currentLevel);
            resetMarioPosition();
            updateStats();
            hideMessage();
            showLevelIndicator();
        }

        function resetGame() {
            currentLevel = 1;
            coins = 0;
            score = 0;
            lives = 3;
            levelComplete = false;
            gameRunning = true;
            generateLevel(currentLevel);
            resetMarioPosition();
            updateStats();
            hideMessage();
            showLevelIndicator();
        }

        function showLevelIndicator() {
            const existing = document.querySelector('.level-indicator');
            if (existing) existing.remove();
            
            const indicator = document.createElement('div');
            indicator.className = 'level-indicator';
            indicator.textContent = `World ${currentLevel}`;
            document.querySelector('.game-container').appendChild(indicator);
            
            setTimeout(() => indicator.remove(), 3000);
        }

        function showMessage(title, subtitle, type) {
            let msg = document.querySelector('.message');
            if (!msg) {
                msg = document.createElement('div');
                msg.className = 'message';
                document.querySelector('.game-container').appendChild(msg);
            }

            let buttons = '';
            if (type === 'nextLevel') {
                buttons = '<button class="green" onclick="nextLevel()">‰∏ã‰∏ÄÈóú ‚Üí</button>';
            } else if (type === 'gameOver') {
                buttons = '<button onclick="resetGame()">ÈáçÊñ∞ÈñãÂßã</button>';
            } else if (type === 'complete') {
                buttons = '<button class="green" onclick="resetGame()">ÂÜçÁé©‰∏ÄÊ¨°</button>';
            }

            msg.innerHTML = `
                <div>${title}</div>
                <div style="font-size: 0.8rem; margin-top: 10px;">${subtitle}</div>
                ${buttons}
            `;
            msg.style.display = 'block';
        }

        function hideMessage() {
            const msg = document.querySelector('.message');
            if (msg) msg.style.display = 'none';
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        generateLevel(1);
        showLevelIndicator();
        gameLoop();
    </script>
</body>
</html>
